









Huge thanks to for sponsoring Sindre Sorhus!





Human-friendly and powerful HTTP request library for Node.js

Moving from Request? (Note that Request is unmaintained)

See how Got compares to other HTTP libraries

For browser usage, we recommend Ky by the same people.

Highlights

Install

$ npm install got

Usage

Promise

const got = require ( ' got ' ) ; ( async ( ) => { try { const response = await got ( ' https://sindresorhus.com ' ) ; console . log ( response . body ) ; } catch ( error ) { console . log ( error . response . body ) ; } } ) ( ) ;

JSON

const got = require ( ' got ' ) ; ( async ( ) => { const { body } = await got . post ( ' https://httpbin.org/anything ' , { json : { hello : ' world ' } , responseType : ' json ' } ) ; console . log ( body . data ) ; } ) ( ) ;

See JSON mode for more details.

Streams

const stream = require ( ' stream ' ) ; const { promisify } = require ( ' util ' ) ; const fs = require ( ' fs ' ) ; const got = require ( ' got ' ) ; const pipeline = promisify ( stream . pipeline ) ; ( async ( ) => { await pipeline ( got . stream ( ' https://sindresorhus.com ' ) , fs . createWriteStream ( ' index.html ' ) ) ; await pipeline ( fs . createReadStream ( ' index.html ' ) , got . stream . post ( ' https://sindresorhus.com ' ) ) ; } ) ( ) ;

Tip: from.pipe(to) doesn't forward errors. Instead, use stream.pipeline(from, ..., to, callback) .

Note: While got.post('https://example.com') resolves, got.stream.post('https://example.com') will hang indefinitely until a body is provided. If there's no body on purpose, remember to .end() the stream or set the body option to an empty string.

API

It's a GET request by default, but can be changed by using different methods or via options.method .

By default, Got will retry on failure. To disable this option, set options.retry to 0 .

Returns a Promise giving a Response object or a Got Stream if options.isStream is set to true.

url

Type: string | object

The URL to request, as a string, a https.request options object, or a WHATWG URL .

Properties from options will override properties in the parsed url .

If no protocol is specified, it will throw a TypeError .

Note: The query string is not parsed as search params. Example:

got('https://example.com/?query=a b'); //=> https://example.com/?query=a%20b got('https://example.com/', {searchParams: {query: 'a b'}}); //=> https://example.com/?query=a+b // The query string is overridden by `searchParams` got('https://example.com/?query=a b', {searchParams: {query: 'a b'}}); //=> https://example.com/?query=a+b

options

Type: object

Any of the https.request options.

Note: Legacy URL support is disabled. options.path is supported only for backwards compatibility. Use options.pathname and options.searchParams instead. options.auth has been replaced with options.username & options.password .

method

Type: string

Default: GET

The HTTP method used to make the request.

prefixUrl

Type: string | URL

When specified, prefixUrl will be prepended to url . The prefix can be any valid URL, either relative or absolute.

A trailing slash / is optional - one will be added automatically.

Note: prefixUrl will be ignored if the url argument is a URL instance.

Note: Leading slashes in input are disallowed when using this option to enforce consistency and avoid confusion. For example, when the prefix URL is https://example.com/foo and the input is /bar , there's ambiguity whether the resulting URL would become https://example.com/foo/bar or https://example.com/bar . The latter is used by browsers.

Tip: Useful when used with got.extend() to create niche-specific Got instances.

Tip: You can change prefixUrl using hooks as long as the URL still includes the prefixUrl . If the URL doesn't include it anymore, it will throw.

const got = require ( ' got ' ) ; ( async ( ) => { await got ( ' unicorn ' , { prefixUrl : ' https://cats.com ' } ) ; const instance = got . extend ( { prefixUrl : ' https://google.com ' } ) ; await instance ( ' unicorn ' , { hooks : { beforeRequest : [ options => { options . prefixUrl = ' https://cats.com ' ; } ] } } ) ; } ) ( ) ;

headers

Type: object

Default: {}

Request headers.

Existing headers will be overwritten. Headers set to undefined will be omitted.

isStream

Type: boolean

Default: false

Returns a Stream instead of a Promise . This is equivalent to calling got.stream(url, options?) .

body

Type: string | Buffer | stream.Readable or form-data instance

Note #1: The body option cannot be used with the json or form option.

Note #2: If you provide this option, got.stream() will be read-only.

Note #3: If you provide a payload with the GET or HEAD method, it will throw a TypeError unless the method is GET and the allowGetBody option is set to true .

Note #4: This option is not enumerable and will not be merged with the instance defaults.

The content-length header will be automatically set if body is a string / Buffer / fs.createReadStream instance / form-data instance, and content-length and transfer-encoding are not manually set in options.headers .

json

Type: object | Array | number | string | boolean | null (JSON-serializable values)

Note #1: If you provide this option, got.stream() will be read-only.

Note #2: This option is not enumerable and will not be merged with the instance defaults.

JSON body. If the Content-Type header is not set, it will be set to application/json .

context

Type: object

User data. In contrast to other options, context is not enumerable.

Note: The object is never merged, it's just passed through. Got will not modify the object in any way.

It's very useful for storing auth tokens:

const got = require ( ' got ' ) ; const instance = got . extend ( { hooks : { beforeRequest : [ options => { if ( ! options . context || ! options . context . token ) { throw new Error ( ' Token required ' ) ; } options . headers . token = options . context . token ; } ] } } ) ; ( async ( ) => { const context = { token : ' secret ' } ; const response = await instance ( ' https://httpbin.org/headers ' , { context } ) ; console . log ( response . body ) ; } ) ( ) ;

responseType

Type: string

Default: 'text'

Note: When using streams, this option is ignored.

The parsing method. Can be 'text' , 'json' or 'buffer' .

The promise also has .text() , .json() and .buffer() methods which return another Got promise for the parsed body.

It's like setting the options to {responseType: 'json', resolveBodyOnly: true} but without affecting the main Got promise.

Example:

( async ( ) => { const responsePromise = got ( url ) ; const bufferPromise = responsePromise . buffer ( ) ; const jsonPromise = responsePromise . json ( ) ; const [ response , buffer , json ] = Promise . all ( [ responsePromise , bufferPromise , jsonPromise ] ) ; } ) ( ) ;

const body = await got ( url ) . json ( ) ; const body = await got ( url , { responseType : ' json ' , resolveBodyOnly : true } ) ;

parseJson

Type: (text: string) => unknown

Default: (text: string) => JSON.parse(text)

A function used to parse JSON responses.

Example Using bourne to prevent prototype pollution: const got = require ( ' got ' ) ; const Bourne = require ( ' @hapi/bourne ' ) ; ( async ( ) => { const parsed = await got ( ' https://example.com ' , { parseJson : text => Bourne . parse ( text ) } ) . json ( ) ; console . log ( parsed ) ; } ) ( ) ;

stringifyJson

Type: (object: unknown) => string

Default: (object: unknown) => JSON.stringify(object)

A function used to stringify the body of JSON requests.

Examples Ignore properties starting with _ : const got = require ( ' got ' ) ; ( async ( ) => { await got . post ( ' https://example.com ' , { stringifyJson : object => JSON . stringify ( object , ( key , value ) => { if ( key . startsWith ( ' _ ' ) ) { return ; } return value ; } ) , json : { some : ' payload ' , _ignoreMe : 1234 } } ) ; } ) ( ) ; All numbers as strings: const got = require ( ' got ' ) ; ( async ( ) => { await got . post ( ' https://example.com ' , { stringifyJson : object => JSON . stringify ( object , ( key , value ) => { if ( typeof value === ' number ' ) { return value . toString ( ) ; } return value ; } ) , json : { some : ' payload ' , number : 1 } } ) ; } ) ( ) ;

resolveBodyOnly

Type: boolean

Default: false

When set to true the promise will return the Response body instead of the Response object.

cookieJar

Type: object | tough.CookieJar instance

Note: If you provide this option, options.headers.cookie will be overridden.

Cookie support. You don't have to care about parsing or how to store them. Example.

Type: Function<Promise>

The function takes two arguments: rawCookie ( string ) and url ( string ).

Type: Function<Promise>

The function takes one argument: url ( string ).

ignoreInvalidCookies

Type: boolean

Default: false

Ignore invalid cookies instead of throwing an error. Only useful when the cookieJar option has been set. Not recommended.

encoding

Type: string

Default: 'utf8'

Encoding to be used on setEncoding of the response data.

To get a Buffer , you need to set responseType to buffer instead. Don't set this option to null .

Note: This doesn't affect streams! Instead, you need to do got.stream(...).setEncoding(encoding) .

form

Type: object

Note #1: If you provide this option, got.stream() will be read-only.

Note #2: This option is not enumerable and will not be merged with the instance defaults.

The form body is converted to a query string using (new URLSearchParams(object)).toString() .

If the Content-Type header is not present, it will be set to application/x-www-form-urlencoded .

searchParams

Type: string | object<string, string | number> | URLSearchParams

Query string that will be added to the request URL. This will override the query string in url .

If you need to pass in an array, you can do it using a URLSearchParams instance:

const got = require ( ' got ' ) ; const searchParams = new URLSearchParams ( [ [ ' key ' , ' a ' ] , [ ' key ' , ' b ' ] ] ) ; got ( ' https://example.com ' , { searchParams } ) ; console . log ( searchParams . toString ( ) ) ;

There are some exceptions in regards to URLSearchParams behavior:

Note #1: null values are not stringified, an empty string is used instead.

Note #2: undefined values are not stringified, the entry is skipped instead.

timeout

Type: number | object

Milliseconds to wait for the server to end the response before aborting the request with got.TimeoutError error (a.k.a. request property). By default, there's no timeout.

This also accepts an object with the following fields to constrain the duration of each phase of the request lifecycle:

lookup starts when a socket is assigned and ends when the hostname has been resolved. Does not apply when using a Unix domain socket.

starts when a socket is assigned and ends when the hostname has been resolved. Does not apply when using a Unix domain socket. connect starts when lookup completes (or when the socket is assigned if lookup does not apply to the request) and ends when the socket is connected.

starts when completes (or when the socket is assigned if lookup does not apply to the request) and ends when the socket is connected. secureConnect starts when connect completes and ends when the handshaking process completes (HTTPS only).

starts when completes and ends when the handshaking process completes (HTTPS only). socket starts when the socket is connected. See request.setTimeout.

starts when the socket is connected. See request.setTimeout. response starts when the request has been written to the socket and ends when the response headers are received.

starts when the request has been written to the socket and ends when the response headers are received. send starts when the socket is connected and ends with the request has been written to the socket.

starts when the socket is connected and ends with the request has been written to the socket. request starts when the request is initiated and ends when the response's end event fires.

retry

Type: number | object

Default:

limit: 2

calculateDelay: ({attemptCount, retryOptions, error, computedValue}) => computedValue | Promise<computedValue>

methods: GET PUT HEAD DELETE OPTIONS TRACE

statusCodes: 408 413 429 500 502 503 504 521 522 524

maxRetryAfter: undefined

errorCodes: ETIMEDOUT ECONNRESET EADDRINUSE ECONNREFUSED EPIPE ENOTFOUND ENETUNREACH EAI_AGAIN

An object representing limit , calculateDelay , methods , statusCodes , maxRetryAfter and errorCodes fields for maximum retry count, retry handler, allowed methods, allowed status codes, maximum Retry-After time and allowed error codes.

Note: When using streams, this option is ignored. If the connection is reset when downloading, you need to catch the error and clear the file you were writing into to prevent duplicated content.

If maxRetryAfter is set to undefined , it will use options.timeout .

If Retry-After header is greater than maxRetryAfter , it will cancel the request.

Delays between retries counts with function 1000 * Math.pow(2, retry) + Math.random() * 100 , where retry is attempt number (starts from 1).

The calculateDelay property is a function that receives an object with attemptCount , retryOptions , error and computedValue properties for current retry count, the retry options, error and default computed value. The function must return a delay in milliseconds (or a Promise resolving with it) ( 0 return value cancels retry).

By default, it retries only on the specified methods, status codes, and on these network errors:

ETIMEDOUT : One of the timeout limits were reached.

: One of the timeout limits were reached. ECONNRESET : Connection was forcibly closed by a peer.

: Connection was forcibly closed by a peer. EADDRINUSE : Could not bind to any free port.

: Could not bind to any free port. ECONNREFUSED : Connection was refused by the server.

: Connection was refused by the server. EPIPE : The remote side of the stream being written has been closed.

: The remote side of the stream being written has been closed. ENOTFOUND : Couldn't resolve the hostname to an IP address.

: Couldn't resolve the hostname to an IP address. ENETUNREACH : No internet connection.

: No internet connection. EAI_AGAIN : DNS lookup timed out.

followRedirect

Type: boolean

Default: true

Defines if redirect responses should be followed automatically.

Note that if a 303 is sent by the server in response to any request type ( POST , DELETE , etc.), Got will automatically request the resource pointed to in the location header via GET . This is in accordance with the spec.

methodRewriting

Type: boolean

Default: true

By default, redirects will use method rewriting. For example, when sending a POST request and receiving a 302 , it will resend the body to the new location using the same HTTP method ( POST in this case).

allowGetBody

Type: boolean

Default: false

Note: The RFC 7321 doesn't specify any particular behavior for the GET method having a payload, therefore it's considered an anti-pattern.

Set this to true to allow sending body for the GET method. However, the HTTP/2 specification says that An HTTP GET request includes request header fields and no payload body , therefore when using the HTTP/2 protocol this option will have no effect. This option is only meant to interact with non-compliant servers when you have no other choice.

maxRedirects

Type: number

Default: 10

If exceeded, the request will be aborted and a MaxRedirectsError will be thrown.

decompress

Type: boolean

Default: true

Decompress the response automatically. This will set the accept-encoding header to gzip, deflate, br on Node.js 11.7.0+ or gzip, deflate for older Node.js versions, unless you set it yourself.

Brotli ( br ) support requires Node.js 11.7.0 or later.

If this is disabled, a compressed response is returned as a Buffer . This may be useful if you want to handle decompression yourself or stream the raw compressed data.

cache

Type: object | false

Default: false

Cache adapter instance for storing cached response data.

dnsCache

Type: CacheableLookup | false

Default: false

An instance of CacheableLookup used for making DNS lookups. Useful when making lots of requests to different public hostnames.

Note: This should stay disabled when making requests to internal hostnames such as localhost , database.local etc.

CacheableLookup uses dns.resolver4(..) and dns.resolver6(...) under the hood and fall backs to dns.lookup(...) when the first two fail, which may lead to additional delay.

dnsLookupIpVersion

Type: 'auto' | 'ipv4' | 'ipv6'

Default: 'auto'

Indicates which DNS record family to use.

Values:

auto : IPv4 (if present) or IPv6

: IPv4 (if present) or IPv6 ipv4 : Only IPv4

: Only IPv4 ipv6 : Only IPv6

Note: If you are using the undocumented option family , dnsLookupIpVersion will override it.

await got ( ' https://api6.ipify.org ' , { dnsLookupIpVersion : ' ipv4 ' } ) ; await got ( ' https://api6.ipify.org ' , { dnsLookupIpVersion : ' ipv6 ' } ) ;

request

Type: Function

Default: http.request | https.request (Depending on the protocol)

Custom request function. The main purpose of this is to support HTTP2 using a wrapper.

http2

Type: boolean

Default: false

If set to true , Got will additionally accept HTTP2 requests.

It will choose either HTTP/1.1 or HTTP/2 depending on the ALPN protocol.

Note: Overriding options.request will disable HTTP2 support.

Note: This option will default to true in the next upcoming major release.

const got = require ( ' got ' ) ; ( async ( ) => { const { headers } = await got ( ' https://nghttp2.org/httpbin/anything ' , { http2 : true } ) ; console . log ( headers . via ) ; } ) ( ) ;

throwHttpErrors

Type: boolean

Default: true

Determines if a got.HTTPError is thrown for unsuccessful responses.

If this is disabled, requests that encounter an error status code will be resolved with the response instead of throwing. This may be useful if you are checking for resource availability and are expecting error responses.

agent

Type: object

An object representing http , https and http2 keys for http.Agent , https.Agent and http2wrapper.Agent instance. This is necessary because a request to one protocol might redirect to another. In such a scenario, Got will switch over to the right protocol agent for you.

If a key is not present, it will default to a global agent.

const got = require ( ' got ' ) ; const HttpAgent = require ( ' agentkeepalive ' ) ; const { HttpsAgent } = HttpAgent ; got ( ' https://sindresorhus.com ' , { agent : { http : new HttpAgent ( ) , https : new HttpsAgent ( ) } } ) ;

hooks

Type: object<string, Function[]>

Hooks allow modifications during the request lifecycle. Hook functions may be async and are run serially.

Type: Function[]

Default: []

Called with plain request options, right before their normalization. This is especially useful in conjunction with got.extend() when the input needs custom handling.

See the Request migration guide for an example.

Note #1: This hook must be synchronous!

Note #2: Errors in this hook will be converted into an instances of RequestError .

Note #3: The options object may not have a url property. To modify it, use a beforeRequest hook instead.

Type: Function[]

Default: []

Called with normalized request options. Got will make no further changes to the request before it is sent. This is especially useful in conjunction with got.extend() when you want to create an API client that, for example, uses HMAC-signing.

See the AWS section for an example.

Tip: You can override the request function by returning a ClientRequest -like instance or a IncomingMessage -like instance. This is very useful when creating a custom cache mechanism.

Type: Function[]

Default: []

Called with normalized request options and the redirect response. Got will make no further changes to the request. This is especially useful when you want to avoid dead sites. Example:

const got = require ( ' got ' ) ; got ( ' https://example.com ' , { hooks : { beforeRedirect : [ ( options , response ) => { if ( options . hostname === ' deadSite ' ) { options . hostname = ' fallbackSite ' ; } } ] } } ) ;

Type: Function[]

Default: []

Note: When using streams, this hook is ignored.

Called with normalized request options, the error and the retry count. Got will make no further changes to the request. This is especially useful when some extra work is required before the next try. Example:

const got = require ( ' got ' ) ; got . post ( ' https://example.com ' , { hooks : { beforeRetry : [ ( options , error , retryCount ) => { if ( error . response . statusCode === 413 ) { options . body = getNewBody ( ) ; } } ] } } ) ;

Note: When retrying in a afterResponse hook, all remaining beforeRetry hooks will be called without the error and retryCount arguments.

Type: Function[]

Default: []

Note: When using streams, this hook is ignored.

Called with response object and a retry function. Calling the retry function will trigger beforeRetry hooks.

Each function should return the response. This is especially useful when you want to refresh an access token. Example:

const got = require ( ' got ' ) ; const instance = got . extend ( { hooks : { afterResponse : [ ( response , retryWithMergedOptions ) => { if ( response . statusCode === 401 ) { const updatedOptions = { headers : { token : getNewToken ( ) } } ; instance . defaults . options = got . mergeOptions ( instance . defaults . options , updatedOptions ) ; return retryWithMergedOptions ( updatedOptions ) ; } return response ; } ] , beforeRetry : [ ( options , error , retryCount ) => { } ] } , mutableDefaults : true } ) ;

Type: Function[]

Default: []

Called with an Error instance. The error is passed to the hook right before it's thrown. This is especially useful when you want to have more detailed errors.

Note: Errors thrown while normalizing input options are thrown directly and not part of this hook.

const got = require ( ' got ' ) ; got ( ' https://api.github.com/some-endpoint ' , { hooks : { beforeError : [ error => { const { response } = error ; if ( response && response . body ) { error . name = ' GitHubError ' ; error . message = ` ${ response . body . message } ( ${ response . statusCode } ) ` ; } return error ; } ] } } ) ;

pagination

Type: object

Note: We're looking for feedback, any ideas on how to improve the API are welcome.

Type: Function

Default: response => JSON.parse(response.body)

A function that transform Response into an array of items. This is where you should do the parsing.

Type: Function

Default: Link header logic

The function takes three arguments:

response - The current response object.

- The current response object. allItems - An array of the emitted items.

- An array of the emitted items. currentItems - Items from the current response.

It should return an object representing Got options pointing to the next page. The options are merged automatically with the previous request, therefore the options returned pagination.paginate(...) must reflect changes only. If there are no more pages, false should be returned.

For example, if you want to stop when the response contains less items than expected, you can use something like this:

const got = require ( ' got ' ) ; ( async ( ) => { const limit = 10 ; const items = got . paginate ( ' https://example.com/items ' , { searchParams : { limit , offset : 0 } , pagination : { paginate : ( response , allItems , currentItems ) => { const previousSearchParams = response . request . options . searchParams ; const previousOffset = previousSearchParams . get ( ' offset ' ) ; if ( currentItems . length < limit ) { return false ; } return { searchParams : { ... previousSearchParams , offset : Number ( previousOffset ) + limit , } } ; } } } ) ; console . log ( ' Items from all pages: ' , items ) ; } ) ( ) ;

Type: Function

Default: (item, allItems, currentItems) => true

Checks whether the item should be emitted or not.

Type: Function

Default: (item, allItems, currentItems) => true

Checks whether the pagination should continue.

For example, if you need to stop before emitting an entry with some flag, you should use (item, allItems, currentItems) => !item.flag . If you want to stop after emitting the entry, you should use (item, allItems, currentItems) => allItems.some(entry => entry.flag) instead.

Type: number

Default: Infinity

The maximum amount of items that should be emitted.

Type: number

Default: 0

Milliseconds to wait before the next request is triggered.

Type: number

Default: 10000

The maximum amount of request that should be triggered. Retries on failure are not counted towards this limit.

For example, it can be helpful during development to avoid an infinite number of requests.

Type: boolean

Default: true

Defines how the parameter allItems in pagination.paginate, pagination.filter and pagination.shouldContinue is managed. When set to false , the parameter allItems is always an empty array.

This option can be helpful to save on memory usage when working with a large dataset.

localAddress

Type: string

The IP address used to send the request from.

Advanced HTTPS API

Note: If the request is not HTTPS, these options will be ignored.

Type: string | Buffer | Array<string | Buffer>

Override the default Certificate Authorities (from Mozilla)

got ( ' https://example.com ' , { https : { certificateAuthority : fs . readFileSync ( ' ./my_ca.pem ' ) } } ) ;

Type: string | Buffer | Array<string | Buffer> | object[]

Private keys in PEM format.

PEM allows the option of private keys being encrypted. Encrypted keys will be decrypted with options.https.passphrase .

Multiple keys with different passphrases can be provided as an array of {pem: <string | Buffer>, passphrase: <string>}

Type: string | Buffer | (string | Buffer)[]

Certificate chains in PEM format.

One cert chain should be provided per private key ( options.https.key ).

When providing multiple cert chains, they do not have to be in the same order as their private keys in options.https.key .

If the intermediate certificates are not provided, the peer will not be able to validate the certificate, and the handshake will fail.

Type: string

The passphrase to decrypt the options.https.key (if different keys have different passphrases refer to options.https.key documentation).

Examples for https.key , https.certificate and https.passphrase

got ( ' https://example.com ' , { https : { key : fs . readFileSync ( ' ./client_key.pem ' ) , certificate : fs . readFileSync ( ' ./client_cert.pem ' ) } } ) ; got ( ' https://example.com ' , { https : { key : [ fs . readFileSync ( ' ./client_key1.pem ' ) , fs . readFileSync ( ' ./client_key2.pem ' ) ] , certificate : [ fs . readFileSync ( ' ./client_cert2.pem ' ) , fs . readFileSync ( ' ./client_cert1.pem ' ) ] } } ) ; got ( ' https://example.com ' , { https : { key : fs . readFileSync ( ' ./client_key.pem ' ) , certificate : fs . readFileSync ( ' ./client_cert.pem ' ) , passphrase : ' client_key_passphrase ' } } ) ; got ( ' https://example.com ' , { https : { key : [ { pem : fs . readFileSync ( ' ./client_key1.pem ' ) , passphrase : ' passphrase1 ' } , { pem : fs . readFileSync ( ' ./client_key2.pem ' ) , passphrase : ' passphrase2 ' } , ] , certificate : [ fs . readFileSync ( ' ./client_cert1.pem ' ) , fs . readFileSync ( ' ./client_cert2.pem ' ) ] } } ) ;

Type: boolean

Default: true

If set to false , all invalid SSL certificates will be ignored and no error will be thrown.

If set to true , it will throw an error whenever an invalid SSL certificate is detected.

We strongly recommend to have this set to true for security reasons.

const got = require ( ' got ' ) ; ( async ( ) => { await got ( ' https://example.com ' , { https : { rejectUnauthorized : true } } ) ; await got ( ' https://localhost ' , { https : { rejectUnauthorized : false } } ) ; await got ( ' https://example.com ' , { https : { rejectUnauthorized : false } } ) ;

Type: Function

Signature: (hostname: string, certificate: DetailedPeerCertificate) => Error | undefined

Default: tls.checkServerIdentity (from the tls module)

This function enable a custom check of the certificate.

Note: In order to have the function called the certificate must not be expired , self-signed or with an untrusted-root .

The function parameters are:

hostname : The server hostname (used when connecting)

: The server hostname (used when connecting) certificate : The server certificate

The function must return undefined if the check succeeded or an Error if it failed.

await got ( ' https://example.com ' , { https : { checkServerIdentity : ( hostname , certificate ) => { if ( hostname === ' example.com ' ) { return ; } return new Error ( ' Invalid Hostname ' ) ; } } } ) ;

Response

The response object will typically be a Node.js HTTP response stream, however, if returned from the cache it will be a response-like object which behaves in the same way.

request

Type: object

Note: This is not a http.ClientRequest.

options - The Got options that were set on this request.

body

Type: string | object | Buffer (Depending on options.responseType )

The result of the request.

rawBody

Type: Buffer

The raw result of the request.

url

Type: string

The request URL or the final URL after redirects.

ip

Type: string

The remote IP address.

Note: Not available when the response is cached. This is hopefully a temporary limitation, see lukechilds/cacheable-request#86.

requestUrl

Type: string

The original request URL.

timings

Type: object

The object contains the following properties:

start - Time when the request started.

- Time when the request started. socket - Time when a socket was assigned to the request.

- Time when a socket was assigned to the request. lookup - Time when the DNS lookup finished.

- Time when the DNS lookup finished. connect - Time when the socket successfully connected.

- Time when the socket successfully connected. secureConnect - Time when the socket securely connected.

- Time when the socket securely connected. upload - Time when the request finished uploading.

- Time when the request finished uploading. response - Time when the request fired response event.

- Time when the request fired event. end - Time when the response fired end event.

- Time when the response fired event. error - Time when the request fired error event.

- Time when the request fired event. abort - Time when the request fired abort event.

- Time when the request fired event. phases wait - timings.socket - timings.start dns - timings.lookup - timings.socket tcp - timings.connect - timings.lookup tls - timings.secureConnect - timings.connect request - timings.upload - (timings.secureConnect || timings.connect) firstByte - timings.response - timings.upload download - timings.end - timings.response total - (timings.end || timings.error || timings.abort) - timings.start



If something has not been measured yet, it will be undefined .

Note: The time is a number representing the milliseconds elapsed since the UNIX epoch.

isFromCache

Type: boolean

Whether the response was retrieved from the cache.

redirectUrls

Type: string[]

The redirect URLs.

retryCount

Type: number

The number of times the request was retried.

Streams

Note: Progress events, redirect events and request/response events can also be used with promises.

Note: To access response.isFromCache you need to use got.stream(url, options).isFromCache . The value will be undefined until the response event.

Sets options.isStream to true .

Returns a duplex stream with additional events:

request event to get the request object of the request.

Tip: You can use request event to abort request:

got . stream ( ' https://github.com ' ) . on ( ' request ' , request => setTimeout ( ( ) => request . destroy ( ) , 50 ) ) ;

The response event to get the response object of the final request.

The redirect event to get the response object of a redirect. The second argument is options for the next request to the redirect location.

Progress events for uploading (sending a request) and downloading (receiving a response). The progress argument is an object like:

{ percent : 0 . 1 , transferred : 1024 , total : 10240 }

If the content-length header is missing, total will be undefined .

( async ( ) => { const response = await got ( ' https://sindresorhus.com ' ) . on ( ' downloadProgress ' , progress => { } ) . on ( ' uploadProgress ' , progress => { } ) ; console . log ( response ) ; } ) ( ) ;

Type: string

The remote IP address.

Type: boolean

Indicates whether the request has been aborted or not.

The same as response.timings .

The same as response.isFromCache .

The same as response.socket .

The emitted error is an instance of RequestError .

Pagination

Returns an async iterator:

( async ( ) => { const countLimit = 10 ; const pagination = got . paginate ( ' https://api.github.com/repos/sindresorhus/got/commits ' , { pagination : { countLimit } } ) ; console . log ( ` Printing latest ${ countLimit } Got commits (newest to oldest): ` ) ; for await ( const commitData of pagination ) { console . log ( commitData . commit . message ) ; } } ) ( ) ;

See options.pagination for more pagination options.

Returns a Promise for an array of all results:

( async ( ) => { const countLimit = 10 ; const results = await got . paginate . all ( ' https://api.github.com/repos/sindresorhus/got/commits ' , { pagination : { countLimit } } ) ; console . log ( ` Printing latest ${ countLimit } Got commits (newest to oldest): ` ) ; console . log ( results ) ; } ) ( ) ;

See options.pagination for more pagination options.

Sets options.method to the method name and makes a request.

Instances

Configure a new got instance with default options . The options are merged with the parent instance's defaults.options using got.mergeOptions . You can access the resolved options with the .defaults property on the instance.

const client = got . extend ( { prefixUrl : ' https://example.com ' , headers : { ' x-unicorn ' : ' rainbow ' } } ) ; client . get ( ' demo ' ) ;

( async ( ) => { const client = got . extend ( { prefixUrl : ' httpbin.org ' , headers : { ' x-foo ' : ' bar ' } } ) ; const { headers } = await client . get ( ' headers ' ) . json ( ) ; const jsonClient = client . extend ( { responseType : ' json ' , resolveBodyOnly : true , headers : { ' x-baz ' : ' qux ' } } ) ; const { headers : headers2 } = await jsonClient . get ( ' headers ' ) ; } ) ( ) ;

Additionally, got.extend() accepts two properties from the defaults object: mutableDefaults and handlers . Example:

const mutableGot = got . extend ( { mutableDefaults : true } ) ; const mergedHandlers = got . extend ( { handlers : [ ( options , next ) => { delete options . headers . referer ; return next ( options ) ; } ] } ) ;

Note: Handlers can be asynchronous. The recommended approach is:

const handler = ( options , next ) => { if ( options . isStream ) { return next ( options ) ; } return ( async ( ) => { try { const response = await next ( options ) ; response . yourOwnProperty = true ; return response ; } catch ( error ) { throw new Error ( ' Your very own error. ' ) ; } } ) ( ) ; } ; const instance = got . extend ( { handlers : [ handler ] } ) ;

Merges many instances into a single one:

options are merged using got.mergeOptions() (including hooks),

(including hooks), handlers are stored in an array (you can access them through instance.defaults.handlers ).

const a = { headers : { cat : ' meow ' } } ; const b = got . extend ( { options : { headers : { cow : ' moo ' } } } ) ; got . extend ( a , b ) ;

Extends parent options. Avoid using object spread as it doesn't work recursively:

const a = { headers : { cat : ' meow ' , wolf : [ ' bark ' , ' wrrr ' ] } } ; const b = { headers : { cow : ' moo ' , wolf : [ ' auuu ' ] } } ; { ... a , ... b } got . mergeOptions ( a , b )

Note: Only Got options are merged! Custom user options should be defined via options.context .

Options are deeply merged to a new object. The value of each key is determined as follows:

If the new property is not defined, the old value is used.

If the new property is explicitly set to undefined : If the parent property is a plain object , the parent value is deeply cloned. Otherwise, undefined is used.

: If the parent value is an instance of URLSearchParams : If the new value is a string , an object or an instance of URLSearchParams , a new URLSearchParams instance is created. The values are merged using urlSearchParams.append(key, value) . The keys defined in the new value override the keys defined in the parent value. Please note that null values point to an empty string and undefined values will exclude the entry. Otherwise, the only available value is undefined .

: If the new property is a plain object : If the parent property is a plain object too, both values are merged recursively into a new object . Otherwise, only the new value is deeply cloned.

: If the new property is an Array , it overwrites the old one with a deep clone of the new property.

, it overwrites the old one with a deep clone of the new property. Properties that are not enumerable, such as context , body , json , and form , will not be merged.

, , , and , will not be merged. Otherwise, the new value is assigned to the key.

const a = { json : { cat : ' meow ' } } ; const b = { json : { cow : ' moo ' } } ; got . mergeOptions ( a , b ) ;

Type: object

The Got defaults used in that instance.

handlers

Type: Function[]

Default: []

An array of functions. You execute them directly by calling got() . They are some sort of "global hooks" - these functions are called first. The last handler (it's hidden) is either asPromise or asStream , depending on the options.isStream property.

Each handler takes two arguments:

Returns a Promise or a Stream depending on options.isStream .

const settings = { handlers : [ ( options , next ) => { if ( options . isStream ) { return next ( options ) . on ( ' request ' , request => { setTimeout ( ( ) => { request . abort ( ) ; } , 50 ) ; } ) ; } return next ( options ) ; } ] , options : got . mergeOptions ( got . defaults . options , { responseType : ' json ' } ) } ; const jsonGot = got . extend ( settings ) ;

mutableDefaults

Type: boolean

Default: false

A read-only boolean describing whether the defaults are mutable or not. If set to true , you can update headers over time, for example, update an access token when it expires.

Types

Got exports some handy TypeScript types and interfaces. See the type definition for all the exported types.

Got

TypeScript will automatically infer types for Got instances, but in case you want to define something like dependencies, you can import the available types directly from Got.

import { GotRequestFunction } from ' got ' ; interface Dependencies { }

Hooks

When writing hooks, you can refer to their types to keep your interfaces consistent.

import { BeforeRequestHook } from ' got ' ;

Errors

Each error contains an options property which are the options Got used to create a request - just to make debugging easier.

Additionaly, the errors may have request (Got Stream) and response (Got Response) properties depending on which phase of the request failed.

When a request fails. Contains a code property with error class code, like ECONNREFUSED . Note that all other types of errors listed below are subclasses of this one, with the exception of CancelError .

When a cache method fails, for example, if the database goes down or there's a filesystem error.

When reading from response stream fails.

When server response code is 2xx, and parsing body fails. Includes a response property.

When the request body is a stream and an error occurs while reading from that stream.

When the server response code is not 2xx nor 3xx if options.followRedirect is true , but always except for 304. Includes a response property.

When the server redirects you more than ten times. Includes a response property.

When given an unsupported protocol.

When the request is aborted due to a timeout. Includes an event and timings property.

When the request is aborted with .cancel() . This type is not a subclass of RequestError as it is re-exported from the p-cancelable package.

Aborting the request

The promise returned by Got has a .cancel() method which when called, aborts the request.

( async ( ) => { const request = got ( url , options ) ; if ( something ) { request . cancel ( ) ; } try { await request ; } catch ( error ) { if ( request . isCanceled ) { } } } ) ( ) ;

When using hooks, simply throw an error to abort the request.

const got = require ( ' got ' ) ; ( async ( ) => { const request = got ( url , { hooks : { beforeRequest : [ ( ) => { throw new Error ( ' Oops. Request canceled. ' ) ; } ] } } ) ; try { await request ; } catch ( error ) { } } ) ( ) ;

To abort the Got Stream request, just call stream.destroy() .

const got = require ( ' got ' ) ; const stream = got . stream ( url ) ; stream . destroy ( ) ;

Cache

Got implements RFC 7234 compliant HTTP caching which works out of the box in-memory and is easily pluggable with a wide range of storage adapters. Fresh cache entries are served directly from the cache, and stale cache entries are revalidated with If-None-Match / If-Modified-Since headers. You can read more about the underlying cache behavior in the cacheable-request documentation. For DNS cache, Got uses cacheable-lookup .

You can use the JavaScript Map type as an in-memory cache:

const got = require ( ' got ' ) ; const map = new Map ( ) ; ( async ( ) => { let response = await got ( ' https://sindresorhus.com ' , { cache : map } ) ; console . log ( response . isFromCache ) ; response = await got ( ' https://sindresorhus.com ' , { cache : map } ) ; console . log ( response . isFromCache ) ; } ) ( ) ;

Got uses Keyv internally to support a wide range of storage adapters. For something more scalable you could use an official Keyv storage adapter:

$ npm install @keyv/redis

const got = require ( ' got ' ) ; const KeyvRedis = require ( ' @keyv/redis ' ) ; const redis = new KeyvRedis ( ' redis://user:pass@localhost:6379 ' ) ; got ( ' https://sindresorhus.com ' , { cache : redis } ) ;

Got supports anything that follows the Map API, so it's easy to write your own storage adapter or use a third-party solution.

For example, the following are all valid storage adapters:

const storageAdapter = new Map ( ) ; const storageAdapter = require ( ' ./my-storage-adapter ' ) ; const QuickLRU = require ( ' quick-lru ' ) ; const storageAdapter = new QuickLRU ( { maxSize : 1000 } ) ; got ( ' https://sindresorhus.com ' , { cache : storageAdapter } ) ;

View the Keyv docs for more information on how to use storage adapters.

Proxies

You can use the tunnel package with the agent option to work with proxies:

const got = require ( ' got ' ) ; const tunnel = require ( ' tunnel ' ) ; got ( ' https://sindresorhus.com ' , { agent : { https : tunnel . httpsOverHttp ( { proxy : { host : ' localhost ' } } ) } } ) ;

Alternatively, use global-agent to configure a global proxy for all HTTP/HTTPS traffic in your program.

Read the http2-wrapper docs to learn about proxying for HTTP/2.

Cookies

You can use the tough-cookie package:

const { promisify } = require ( ' util ' ) ; const got = require ( ' got ' ) ; const { CookieJar } = require ( ' tough-cookie ' ) ; ( async ( ) => { const cookieJar = new CookieJar ( ) ; const setCookie = promisify ( cookieJar . setCookie . bind ( cookieJar ) ) ; await setCookie ( ' foo=bar ' , ' https://example.com ' ) ; await got ( ' https://example.com ' , { cookieJar } ) ; } ) ( ) ;

Form data

You can use the form-data package to create POST request with form data:

const fs = require ( ' fs ' ) ; const got = require ( ' got ' ) ; const FormData = require ( ' form-data ' ) ; const form = new FormData ( ) ; form . append ( ' my_file ' , fs . createReadStream ( ' /foo/bar.jpg ' ) ) ; got . post ( ' https://example.com ' , { body : form } ) ;

OAuth

You can use the oauth-1.0a package to create a signed OAuth request:

const got = require ( ' got ' ) ; const crypto = require ( ' crypto ' ) ; const OAuth = require ( ' oauth-1.0a ' ) ; const oauth = OAuth ( { consumer : { key : process . env . CONSUMER_KEY , secret : process . env . CONSUMER_SECRET } , signature_method : ' HMAC-SHA1 ' , hash_function : ( baseString , key ) => crypto . createHmac ( ' sha1 ' , key ) . update ( baseString ) . digest ( ' base64 ' ) } ) ; const token = { key : process . env . ACCESS_TOKEN , secret : process . env . ACCESS_TOKEN_SECRET } ; const url = ' https://api.twitter.com/1.1/statuses/home_timeline.json ' ; got ( url , { headers : oauth . toHeader ( oauth . authorize ( { url , method : ' GET ' } , token ) ) , responseType : ' json ' } ) ;

Unix Domain Sockets

Requests can also be sent via unix domain sockets. Use the following URL scheme: PROTOCOL://unix:SOCKET:PATH .

PROTOCOL - http or https (optional)

- or (optional) SOCKET - Absolute path to a unix domain socket, for example: /var/run/docker.sock

- Absolute path to a unix domain socket, for example: PATH - Request path, for example: /v2/keys

const got = require ( ' got ' ) ; got ( ' http://unix:/var/run/docker.sock:/containers/json ' ) ; got ( ' unix:/var/run/docker.sock:/containers/json ' ) ;

AWS

Requests to AWS services need to have their headers signed. This can be accomplished by using the aws4 package. This is an example for querying an "API Gateway" with a signed request.

const got = require ( ' got ' ) ; const AWS = require ( ' aws-sdk ' ) ; const aws4 = require ( ' aws4 ' ) ; const chain = new AWS . CredentialProviderChain ( ) ; const awsClient = got . extend ( { prefixUrl : ' https://<api-id>.execute-api.<api-region>.amazonaws.com/<stage>/ ' , hooks : { beforeRequest : [ async options => { const credentials = await chain . resolvePromise ( ) ; aws4 . sign ( options , credentials ) ; } ] } } ) ; const response = await awsClient ( ' endpoint/path ' , { } ) ;

Testing

You can test your requests by using the nock package to mock an endpoint:

const got = require ( ' got ' ) ; const nock = require ( ' nock ' ) ; nock ( ' https://sindresorhus.com ' ) . get ( ' / ' ) . reply ( 200 , ' Hello world! ' ) ; ( async ( ) => { const response = await got ( ' https://sindresorhus.com ' ) ; console . log ( response . body ) ; } ) ( ) ;

For real integration testing we recommend using ava with create-test-server . We're using a macro so we don't have to server.listen() and server.close() every test. Take a look at one of our tests:

test ( ' retry function gets iteration count ' , withServer , async ( t , server , got ) => { let knocks = 0 ; server . get ( ' / ' , ( request , response ) => { if ( knocks ++ === 1 ) { response . end ( ' who`s there? ' ) ; } } ) ; await got ( { retry : { calculateDelay : ( { attemptCount } ) => { t . true ( is . number ( attemptCount ) ) ; return attemptCount < 2 ? 1 : 0 ; } } } ) ; } ) ;

Tips

JSON mode

To pass an object as the body, you need to use the json option. It will be stringified using JSON.stringify . Example:

const got = require ( ' got ' ) ; ( async ( ) => { const { body } = await got . post ( ' https://httpbin.org/anything ' , { json : { hello : ' world ' } , responseType : ' json ' } ) ; console . log ( body . data ) ; } ) ( ) ;

To receive a JSON body you can either set responseType option to json or use promise.json() . Example:

const got = require ( ' got ' ) ; ( async ( ) => { const body = await got . post ( ' https://httpbin.org/anything ' , { json : { hello : ' world ' } } ) . json ( ) ; console . log ( body ) ; } ) ( ) ;

User Agent

It's a good idea to set the 'user-agent' header so the provider can more easily see how their resource is used. By default, it's the URL to this repo. You can omit this header by setting it to undefined .

const got = require ( ' got ' ) ; const pkg = require ( ' ./package.json ' ) ; got ( ' https://sindresorhus.com ' , { headers : { ' user-agent ' : ` my-package/ ${ pkg . version } ( https://github.com/username/my-package ) ` } } ) ; got ( ' https://sindresorhus.com ' , { headers : { ' user-agent ' : undefined } } ) ;

304 Responses

Bear in mind; if you send an if-modified-since header and receive a 304 Not Modified response, the body will be empty. It's your responsibility to cache and retrieve the body contents.

Custom endpoints

Use got.extend() to make it nicer to work with REST APIs. Especially if you use the prefixUrl option.

const got = require ( ' got ' ) ; const pkg = require ( ' ./package.json ' ) ; const custom = got . extend ( { prefixUrl : ' example.com ' , responseType : ' json ' , headers : { ' user-agent ' : ` my-package/ ${ pkg . version } ( https://github.com/username/my-package ) ` } } ) ; ( async ( ) => { const list = await custom ( ' v1/users/list ' ) ; } ) ( ) ;

FAQ

Why yet another HTTP client?

Got was created because the popular request package is bloated:

Furthermore, Got is fully written in TypeScript and actively maintained.

Electron support has been removed

The Electron net module is not consistent with the Node.js http module. See #899 for more info.

Comparison

* It's almost API compatible with the browser fetch API.

** Need to switch the protocol manually. Doesn't accept PUSH streams and doesn't reuse HTTP/2 sessions.

*** Currently, only DownloadProgress event is supported, UploadProgress event is not supported.

❇️ Almost-stable feature, but the API may change. Don't hestitate to try it out!

❔ Feature in early stage of development. Very experimental.

Click here to see the install size of the Got dependencies.

Related

gh-got - Got convenience wrapper to interact with the GitHub API

gl-got - Got convenience wrapper to interact with the GitLab API

travis-got - Got convenience wrapper to interact with the Travis API

graphql-got - Got convenience wrapper to interact with GraphQL

GotQL - Got convenience wrapper to interact with GraphQL using JSON-parsed queries instead of strings

got-fetch - Got with a fetch interface

Maintainers

Former

For enterprise

Available as part of the Tidelift Subscription.